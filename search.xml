<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pae</title>
      <link href="/2022/12/03/page-6/"/>
      <url>/2022/12/03/page-6/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>在用指针进行排序时，</p><p>要注意交换的是值而不是指针。</p><p>如先定义a,b,c和*pa ,*pb,*pc令pa=a的地址，pb=b的地址，pc=c的地址,再定义一个常量作为中间变量。</p><p>#include &lt;stdio.h&gt;<br>lint main(） {<br>int a, b,c，<em>pa，</em>pb，*pc,p;</p><p>pa = &a;<br>pb = &b;</p><p>pc = &c;<br>printf(“请输入三个整数a, b,c\n”);</p><p>scanf(“%d%d%d”，&amp;a，&amp;b，&amp;c);</p><p>if (a&lt; b){<br>p = pa;</p><p>pa = pb;</p><p>pb = p;</p><p>}<br>if (a&lt; c){<br>p= pa;</p><p>pa = pc;</p><p>pc = p;</p><p>}<br>if (b &lt;c){<br>p = pb ;</p><p>pb = pc;</p><p>pc = p;</p><p>}<br>printf (“%d \t%d\t%d”，<em>pa，</em>pb,*pc);<br>return 0;</p><p>}</p><p>注意以上代码是错误的，不能正确排序，因为它只交换了指针，没有改变变量的值。因此我们应该交换的是<em>pa，</em>pb,*pc.</p><p>正确代码如下：</p><p>#include &lt;stdio.h&gt;<br>int main() {<br>    int a, b, c, * pa, * pb, * pc,x;<br>    pa = &a;<br>    pb = &b;<br>    pc = &c;<br>    printf(“请输入三个整数a b c\n”);<br>    scanf(“%d %d %d”,&amp; a,&amp; b,&amp; c);<br>    if (*pa &lt; *pb) {<br>        x = *pa;<br>        *pa = *pb;<br>        *pb = x;<br>    }<br>    if (*pa &lt; *pc) {<br>        x = *pa;<br>        *pa = *pc;<br>        *pc = x;<br>    }<br>    if (*pb &lt; *pc) {<br>        x = *pb;<br>        *pb = *pc;<br>        *pc = x;<br>    }<br>    printf(“%d\t%d\t%d”, *pa, *pb, *pc);</p><p>return 0;</p><p>}</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>page</title>
      <link href="/2022/12/03/page-5/"/>
      <url>/2022/12/03/page-5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>代码如下</p><p>#define     _CRT_SECURE_NO_WARNINGS<br>#include &lt;stdio.h&gt;<br>int main() {<br>    int i, j, n, a[50][50];<br>    scanf(“%d”, &amp;n);<br>    for (i = 0; i &lt; n; i++) {<br>        a[i][i] = 1;<br>        a[i][0] = 1;<br>    }<br>    for (i = 2; i &lt; n; i++) {<br>            for (j = 1; j &lt;i; j++)<br>                a[i][j] = a[i - 1][j - 1] + a[i - 1][j];<br>    }<br>    for (i = 0; i &lt; n; i++) {<br>        for (j = 0; j &lt;=i; j++)<br>            printf(“%5d”, a[i][j]);<br>        printf(“\n”);<br>    }<br>    return 0;<br>}</p><p>另一种形式如下</p><p>#include &lt;stdio.h&gt;<br>int main() {<br>    int i, j, n, a[50][50]={0};<br>    scanf(“%d”, &amp;n);<br>    for (i = 0; i &lt; n; i++) {<br>        a[i][i] = 1;<br>        a[i][0] = 1;<br>    }<br>    for (i = 2; i &lt; n; i++) {<br>            for (j = 1; j &lt;=i; j++)<br>                a[i][j] = a[i - 1][j - 1] + a[i - 1][j];<br>    }<br>    for (i = 0; i &lt; n; i++) {<br>        for (j = 0; j &lt;=i; j++)<br>            printf(“%5d”, a[i][j]);<br>        printf(“\n”);<br>    }<br>    return 0;<br>}</p><p>可见第二段代码与第一段代码的区别在于输入的for循环的j是小于等于i而第一个是小于i，这样的话，第二段代码便要对数组进行初始化，否则会出现差错。</p><p>对程序分析可知</p><p>从全局来看可以发现第n行共有n个元素。我们首先对每一行的第一个位置和最后一个位置赋予值1，由于第二行是1 ，1，故从第三行对代码的规律进行总结。可以发现第三行开始，每一行的第二个元素到第n-1个元素的每一个元素都是上一行对应位置元素和上一行对应位置元素的左边一个元素之和.</p><p>1</p><p>1  1</p><p>1  2  1</p><p>1  3  3  1</p><p>1  4  6  4  1</p><p>故从第三行开始我们代码每一行都只需对第二个元素到倒数第二个元素进行分析输出，第一段代码无需初始化是因为j的输出只到了i-1的位置就是如上所说。而第二段代码到了i的位置，也就是对每一行最后一个值1又进行了输出覆盖了原来的值1，此时第三行最后一个元素的值会对于第二行第三个元素的值加上1，如果不初始化数组令其等于0，由于第二行第三个元素的值未定所以最后结果便会出错。若初始化令其为0，则由于0+1=1保证了每一行最后一个仍是1，所以使得程序正常输出。</p><p>，</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>if语句</title>
      <link href="/2022/10/10/page-4/"/>
      <url>/2022/10/10/page-4/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天记录下if语句</p><p>1.if（表达式）{}</p><p>//若条件不是这个就是那个可以不用花括号即仅为一简单语句时</p><p>2.也可用 if else语句</p><p>if(表达式){</p><p>语句a</p><p>}</p><p>else{</p><p>语句b</p><p>}</p><p>3.还有if……else if</p><p>与上面相同</p><p>if（表达式）{</p><p>语句a</p><p>}</p><p>else if{</p><p>语句b</p><p>}</p><p>可追加else{</p><p>语句c</p><p>}</p><p>以此类推进行</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>缓冲区溢出（摘录）</title>
      <link href="/2022/10/05/page-3/"/>
      <url>/2022/10/05/page-3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于C/C++语言本身没有<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&spm=1001.2101.3001.7020">数组</a>越界检查机制，当向缓冲区里写入的数据超过了为其分配的大小时，就会发生缓冲区溢出。</p><p>Text段主要包含程序代码（一系列可执行的指令），另外还有一些只读的数据。通常操作系统标记该段为只读段，</p><p>如果有进程试图修改该段，会引发段错误。</p><p>Data段包括已初始化和未初始化的<a href="https://so.csdn.net/so/search?q=%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F&spm=1001.2101.3001.7020">全局变量</a>，静态变量也放于此处。该段的大小是在编译时期计算的。</p><p>紧接着Data段的一块内存是由堆和栈共享的区域。堆向下（高地址）增长，栈向上（低地址）增长。</p><p>堆中保存动态分配的数据，调用malloc函数或者calloc函数或者使用new操作符会在堆上分配内存。</p><p>栈中保存的是函数调用时传递的参数，局部变量的值和一些记录进程运行状态的寄存器的值。</p><p>堆和栈所占内存都是在运行期间分配的。如果进程的堆或栈的增长超出了为进程分配的内存大小，</p><p>那么该进程会被阻塞，操作系统重新为其分派一块更大的内存。</p><p><strong>栈的作用</strong></p><p>栈这种数据结构，我们再熟悉不过。它的特点是后进先出（LIFO），在它之上有两个著名的函数，push和pop。</p><p>函数是结构化程序设计最重要的技术。程序的执行过程可以看作是连续的函数调用。当一个函数执行完毕时，程序要回到调用</p><p>指令的下一条指令（紧接call指令）处继续执行，而栈的特点刚好适合这个条件。</p><p>在介绍函数调用的细节之前，我们先来看一下栈帧的概念。</p><p>栈帧是栈中的逻辑片段。每个函数调用时，都会push一个栈帧，当函数返回时，pop。</p><p>栈帧里面存放着函数的参数，函数局部变量以及为了恢复前一栈帧所需要的数据。</p><p> 我们知道，栈是实现相关的，不同架构的计算机，栈的增长方向和栈顶指针（ESP）的指向是不一样的。这篇文章里所讲的栈，</p><p>都是向低地址增长，栈顶指针是指向栈顶的。 由于ESP的值在程序执行过程中会频繁的改变，用到它的偏移量来定位变量会</p><p>很麻烦。因此，编译器使用另外一个寄存器EBP来记录执行时，首先把旧的EBP值压栈，然后把当前ESP值作为新的EBP值，接着</p><p>改变ESP值来为函数局部变量预留出空间。</p><p>转载：<a href="https://www.cnblogs.com/shilcare/archive/2010/12/23/1912987.html">缓冲区溢出攻击原理、方法及防范（一） -shilcare - 博客园 (cnblogs.com)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>浅谈内存</title>
      <link href="/2022/10/01/page-2/"/>
      <url>/2022/10/01/page-2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>1.内存(Memory)是<a href="https://baike.baidu.com/item/%E8%AE%A1%E7%AE%97%E6%9C%BA/140338?fromModule=lemma_inlink">计算机</a>的重要部件，也称<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E5%82%A8%E5%99%A8/834392?fromModule=lemma_inlink">内存储器</a>和<a href="https://baike.baidu.com/item/%E4%B8%BB%E5%AD%98%E5%82%A8%E5%99%A8/10635399?fromModule=lemma_inlink">主存储器</a>，它用于暂时存放CPU中的运算数据，以及与<a href="https://baike.baidu.com/item/%E7%A1%AC%E7%9B%98/159825?fromModule=lemma_inlink">硬盘</a>等<a href="https://baike.baidu.com/item/%E5%A4%96%E9%83%A8%E5%AD%98%E5%82%A8%E5%99%A8/4843180?fromModule=lemma_inlink">外部存储器</a>交换的数据。它是<a href="https://baike.baidu.com/item/%E5%A4%96%E5%AD%98/2445612?fromModule=lemma_inlink">外存</a>与<a href="https://baike.baidu.com/item/CPU/120556?fromModule=lemma_inlink">CPU</a>进行沟通的桥梁，计算机中所有程序的运行都在内存中进行，内存性能的强弱影响计算机整体发挥的水平。只要计算机开始运行，<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192?fromModule=lemma_inlink">操作系统</a>就会把需要运算的数据从内存调到CPU中进行运算，当运算完成，CPU将结果传送出来。</p><p>2.为了有效的使用内存，把内存划分成一个个小的内存单元，每个内存单元的大小是1个字节。</p><p>3.为了能够有效的访问即快速找到内存的每个单元，就给内存单元进行了编号，这些编号被称为该内存单元的地址。</p><p>4.内存分配：在C/C++中内存分为5个区，分别为栈区、堆区、全局/静态存储区、常量存储区、代码区。</p><p>静态内存分配:编译时分配。包括:全局、静态全局、静态局部三种变量。</p><p>动态内存分配:运行时分配。包括:栈(stack): 局部变量。堆(heap):c语言中用到的变量被动态的分配在内存中。(malloc或calloc、realloc、free函数)</p><ol start="5"><li>栈区（stack）：指那些由编译器在需要的时候分配，不需要时自动清除的变量所在的储存区，如函数执行时，函数的形参以及函数内的局部变量分配在栈区，函数运行结束后，形参和局部变量去栈（自动释放）。栈内存分配运算内置与处理器的指令集中，效率高但是分配的内存空间有限。</li></ol><p>堆区（heap）：指哪些由程序员手动分配释放的储存区，如果程序员不释放这块内存，内存将一直被占用，直到程序运行结束由系统自动收回，c语言中使用malloc，free申请和释放空间。</p><p>静态储存区（static）：全局变量和静态变量的储存是放在一块的，其中初始化的全局变量和静态变量在一个区域，这块空间当程序运行结束后由系统释放。</p><p>常量储存区（const）：常量字符串就是储存在这里的，如“ABC”字符串就储存在常量区，储存在常量区的只读不可写。const修饰的全局变量也储存在常量区，const修饰的局部变量依然在栈上。</p><p>程序代码区：存放源程序的二进制代码。</p><p>————————————————</p><p>版权声明：本文为CSDN博主「wy无语」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：<a href="https://blog.csdn.net/wy749929317/article/details/123729606">https://blog.csdn.net/wy749929317/article/details/123729606</a></p><p>————————————————</p><p>版权声明：本文为CSDN博主「wy无语」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：<a href="https://blog.csdn.net/wy749929317/article/details/123729606">C语言内存分配_wy无语的博客-CSDN博客_c语言内存分配</a></p><p>1取自百度百科</p><p>2，3取自博客园</p><p>其余取自csdn博主</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>博客的搭建</title>
      <link href="/2022/09/26/page/"/>
      <url>/2022/09/26/page/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p> 今日整理下博客的搭建。</p><p>关于博客的搭建共耗时5个小时，当时懵懂的我看着一堆的fault人都傻了，不过万幸的是最后还是搭建好了</p><p>我第一步先去github官网注册了自己的账号，然后成功创建了我的博客的域名，</p><p>而后遵循网络的指导先后安装了git，node.js，hexo</p><p>此时我发现还得去GitHub上生成ssh密钥，待密钥安装好后我便检查了hexo，git等的安装</p><p>然后去修改了下_config.yml文件</p><p>最后在hexo clean，hexo g   ，hexo d 后成功生成了属于我的blog</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>整型溢出（1）</title>
      <link href="/2022/09/25/page-1/"/>
      <url>/2022/09/25/page-1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>今天由于某些原因简单了解下整型溢出，在此简单整理下：</p><p>通常来说，整数溢出指的是整数达到其字节大小极限时的一种情况。</p><p>原理：</p><p>计算机中整数变量有上下界，如果在算术运算中出现越界，就会出现两类整数溢出。超出整数类型的最大表示范围，数字便会由一个极大值变为一个极小值或直接归零，这叫“上溢”； 超出整数类型的最小表示范围的话，数字便会由一个极小值或者零变成一个极大值，这叫做“下溢”。</p><p>而其后果轻则导致运算结果出错，重则导致内存被覆盖、缓冲区溢出、被黑客攻击、系统崩溃。</p><p>（以上内容均取自网络）</p><p>此处仅为简单介绍概念，以后若有机会再深入研究</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
